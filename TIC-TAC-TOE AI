import React, { useState, useEffect } from 'react';
import { Brain, User, Trophy, RotateCcw, Zap, Settings } from 'lucide-react';

const TicTacToeAI = () => {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [isPlayerTurn, setIsPlayerTurn] = useState(true);
  const [gameOver, setGameOver] = useState(false);
  const [winner, setWinner] = useState(null);
  const [difficulty, setDifficulty] = useState('unbeatable');
  const [playerSymbol, setPlayerSymbol] = useState('X');
  const [aiSymbol, setAiSymbol] = useState('O');
  const [scores, setScores] = useState({ player: 0, ai: 0, draws: 0 });
  const [thinking, setThinking] = useState(false);
  const [lastMove, setLastMove] = useState(null);
  const [moveCount, setMoveCount] = useState(0);
  const [algorithm, setAlgorithm] = useState('alphabeta');
  const [searchStats, setSearchStats] = useState({ nodes: 0, depth: 0, time: 0 });

  const winningCombinations = [
    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
    [0, 4, 8], [2, 4, 6] // Diagonals
  ];

  const checkWinner = (boardState) => {
    for (let combo of winningCombinations) {
      const [a, b, c] = combo;
      if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
        return { winner: boardState[a], line: combo };
      }
    }
    if (boardState.every(cell => cell !== null)) {
      return { winner: 'draw', line: null };
    }
    return null;
  };

  const getAvailableMoves = (boardState) => {
    return boardState.map((cell, idx) => cell === null ? idx : null).filter(val => val !== null);
  };

  // Minimax algorithm without pruning
  const minimax = (boardState, depth, isMaximizing, stats) => {
    stats.nodes++;
    stats.depth = Math.max(stats.depth, depth);

    const result = checkWinner(boardState);
    if (result) {
      if (result.winner === aiSymbol) return 10 - depth;
      if (result.winner === playerSymbol) return depth - 10;
      return 0;
    }

    const availableMoves = getAvailableMoves(boardState);

    if (isMaximizing) {
      let bestScore = -Infinity;
      for (let move of availableMoves) {
        const newBoard = [...boardState];
        newBoard[move] = aiSymbol;
        const score = minimax(newBoard, depth + 1, false, stats);
        bestScore = Math.max(score, bestScore);
      }
      return bestScore;
    } else {
      let bestScore = Infinity;
      for (let move of availableMoves) {
        const newBoard = [...boardState];
        newBoard[move] = playerSymbol;
        const score = minimax(newBoard, depth + 1, true, stats);
        bestScore = Math.min(score, bestScore);
      }
      return bestScore;
    }
  };

  // Minimax with Alpha-Beta Pruning
  const minimaxAlphaBeta = (boardState, depth, alpha, beta, isMaximizing, stats) => {
    stats.nodes++;
    stats.depth = Math.max(stats.depth, depth);

    const result = checkWinner(boardState);
    if (result) {
      if (result.winner === aiSymbol) return 10 - depth;
      if (result.winner === playerSymbol) return depth - 10;
      return 0;
    }

    const availableMoves = getAvailableMoves(boardState);

    if (isMaximizing) {
      let bestScore = -Infinity;
      for (let move of availableMoves) {
        const newBoard = [...boardState];
        newBoard[move] = aiSymbol;
        const score = minimaxAlphaBeta(newBoard, depth + 1, alpha, beta, false, stats);
        bestScore = Math.max(score, bestScore);
        alpha = Math.max(alpha, score);
        if (beta <= alpha) break; // Beta cutoff
      }
      return bestScore;
    } else {
      let bestScore = Infinity;
      for (let move of availableMoves) {
        const newBoard = [...boardState];
        newBoard[move] = playerSymbol;
        const score = minimaxAlphaBeta(newBoard, depth + 1, alpha, beta, true, stats);
        bestScore = Math.min(score, bestScore);
        beta = Math.min(beta, score);
        if (beta <= alpha) break; // Alpha cutoff
      }
      return bestScore;
    }
  };

  const getBestMove = (boardState) => {
    const startTime = performance.now();
    const stats = { nodes: 0, depth: 0, time: 0 };
    
    let bestScore = -Infinity;
    let bestMove = null;
    const availableMoves = getAvailableMoves(boardState);

    for (let move of availableMoves) {
      const newBoard = [...boardState];
      newBoard[move] = aiSymbol;
      
      let score;
      if (algorithm === 'alphabeta') {
        score = minimaxAlphaBeta(newBoard, 0, -Infinity, Infinity, false, stats);
      } else {
        score = minimax(newBoard, 0, false, stats);
      }

      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
    }

    stats.time = (performance.now() - startTime).toFixed(2);
    setSearchStats(stats);
    return bestMove;
  };

  const getRandomMove = (boardState) => {
    const availableMoves = getAvailableMoves(boardState);
    return availableMoves[Math.floor(Math.random() * availableMoves.length)];
  };

  const getEasyMove = (boardState) => {
    // 70% random, 30% optimal
    return Math.random() < 0.7 ? getRandomMove(boardState) : getBestMove(boardState);
  };

  const getMediumMove = (boardState) => {
    // 40% random, 60% optimal
    return Math.random() < 0.4 ? getRandomMove(boardState) : getBestMove(boardState);
  };

  const getAIMove = (boardState) => {
    switch (difficulty) {
      case 'easy':
        return getEasyMove(boardState);
      case 'medium':
        return getMediumMove(boardState);
      case 'unbeatable':
        return getBestMove(boardState);
      default:
        return getBestMove(boardState);
    }
  };

  const handleCellClick = (index) => {
    if (board[index] || gameOver || !isPlayerTurn || thinking) return;

    const newBoard = [...board];
    newBoard[index] = playerSymbol;
    setBoard(newBoard);
    setLastMove(index);
    setMoveCount(moveCount + 1);

    const result = checkWinner(newBoard);
    if (result) {
      endGame(result);
      return;
    }

    setIsPlayerTurn(false);
  };

  useEffect(() => {
    if (!isPlayerTurn && !gameOver) {
      setThinking(true);
      
      const timeout = setTimeout(() => {
        const aiMove = getAIMove(board);
        const newBoard = [...board];
        newBoard[aiMove] = aiSymbol;
        setBoard(newBoard);
        setLastMove(aiMove);
        setMoveCount(moveCount + 1);
        setThinking(false);

        const result = checkWinner(newBoard);
        if (result) {
          endGame(result);
        } else {
          setIsPlayerTurn(true);
        }
      }, 500);

      return () => clearTimeout(timeout);
    }
  }, [isPlayerTurn, gameOver]);

  const endGame = (result) => {
    setGameOver(true);
    setWinner(result);
    
    if (result.winner === playerSymbol) {
      setScores({ ...scores, player: scores.player + 1 });
    } else if (result.winner === aiSymbol) {
      setScores({ ...scores, ai: scores.ai + 1 });
    } else {
      setScores({ ...scores, draws: scores.draws + 1 });
    }
  };

  const resetGame = () => {
    setBoard(Array(9).fill(null));
    setIsPlayerTurn(playerSymbol === 'X');
    setGameOver(false);
    setWinner(null);
    setLastMove(null);
    setMoveCount(0);
    setSearchStats({ nodes: 0, depth: 0, time: 0 });
  };

  const resetScores = () => {
    setScores({ player: 0, ai: 0, draws: 0 });
    resetGame();
  };

  const switchSides = () => {
    const newPlayerSymbol = playerSymbol === 'X' ? 'O' : 'X';
    const newAiSymbol = aiSymbol === 'X' ? 'O' : 'X';
    setPlayerSymbol(newPlayerSymbol);
    setAiSymbol(newAiSymbol);
    resetGame();
  };

  const getCellClass = (index) => {
    let baseClass = "w-24 h-24 border-2 border-purple-400 flex items-center justify-center text-5xl font-bold cursor-pointer transition-all duration-200 ";
    
    if (board[index]) {
      baseClass += board[index] === playerSymbol ? "text-blue-400 " : "text-red-400 ";
    }
    
    if (lastMove === index) {
      baseClass += "bg-yellow-500/20 ";
    } else if (board[index]) {
      baseClass += "bg-white/5 ";
    } else {
      baseClass += "hover:bg-white/10 ";
    }

    if (winner?.line?.includes(index)) {
      baseClass += "bg-green-500/30 animate-pulse ";
    }

    return baseClass;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-6">
      <div className="max-w-6xl mx-auto">
        <div className="text-center mb-8">
          <h1 className="text-5xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
            Tic-Tac-Toe AI
          </h1>
          <p className="text-gray-300">Powered by Minimax Algorithm with Alpha-Beta Pruning</p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Settings & Stats */}
          <div className="space-y-4">
            <div className="bg-white/10 backdrop-blur-lg rounded-lg p-6 border border-white/20">
              <h2 className="text-xl font-bold mb-4 flex items-center">
                <Settings className="mr-2" />
                Game Settings
              </h2>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-sm mb-2">AI Difficulty</label>
                  <select
                    value={difficulty}
                    onChange={(e) => setDifficulty(e.target.value)}
                    className="w-full p-2 bg-white/5 border border-white/20 rounded text-white"
                    disabled={!gameOver && moveCount > 0}
                  >
                    <option value="easy">Easy (30% optimal)</option>
                    <option value="medium">Medium (60% optimal)</option>
                    <option value="unbeatable">Unbeatable (100%)</option>
                  </select>
                </div>

                <div>
                  <label className="block text-sm mb-2">Algorithm</label>
                  <select
                    value={algorithm}
                    onChange={(e) => setAlgorithm(e.target.value)}
                    className="w-full p-2 bg-white/5 border border-white/20 rounded text-white"
                  >
                    <option value="alphabeta">Alpha-Beta Pruning</option>
                    <option value="minimax">Standard Minimax</option>
                  </select>
                </div>

                <button
                  onClick={switchSides}
                  className="w-full p-3 bg-purple-500 hover:bg-purple-600 rounded-lg transition"
                  disabled={!gameOver && moveCount > 0}
                >
                  Switch Sides (You: {playerSymbol})
                </button>
              </div>
            </div>

            <div className="bg-white/10 backdrop-blur-lg rounded-lg p-6 border border-white/20">
              <h2 className="text-xl font-bold mb-4 flex items-center">
                <Trophy className="mr-2" />
                Score Board
              </h2>
              
              <div className="space-y-3">
                <div className="flex justify-between items-center p-3 bg-blue-500/20 rounded">
                  <span className="flex items-center">
                    <User className="mr-2" size={20} />
                    Player ({playerSymbol})
                  </span>
                  <span className="text-2xl font-bold">{scores.player}</span>
                </div>

                <div className="flex justify-between items-center p-3 bg-red-500/20 rounded">
                  <span className="flex items-center">
                    <Brain className="mr-2" size={20} />
                    AI ({aiSymbol})
                  </span>
                  <span className="text-2xl font-bold">{scores.ai}</span>
                </div>

                <div className="flex justify-between items-center p-3 bg-gray-500/20 rounded">
                  <span>Draws</span>
                  <span className="text-2xl font-bold">{scores.draws}</span>
                </div>

                <button
                  onClick={resetScores}
                  className="w-full p-2 bg-white/5 hover:bg-white/10 rounded transition text-sm"
                >
                  Reset Scores
                </button>
              </div>
            </div>

            <div className="bg-white/10 backdrop-blur-lg rounded-lg p-6 border border-white/20">
              <h2 className="text-xl font-bold mb-4 flex items-center">
                <Zap className="mr-2" />
                AI Statistics
              </h2>
              
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span>Nodes Explored:</span>
                  <span className="font-bold">{searchStats.nodes}</span>
                </div>
                <div className="flex justify-between">
                  <span>Max Depth:</span>
                  <span className="font-bold">{searchStats.depth}</span>
                </div>
                <div className="flex justify-between">
                  <span>Computation Time:</span>
                  <span className="font-bold">{searchStats.time}ms</span>
                </div>
                <div className="flex justify-between">
                  <span>Algorithm:</span>
                  <span className="font-bold capitalize">{algorithm === 'alphabeta' ? 'Î±-Î² Pruning' : 'Minimax'}</span>
                </div>
              </div>

              {algorithm === 'alphabeta' && searchStats.nodes > 0 && (
                <div className="mt-4 p-3 bg-green-500/20 rounded text-xs">
                  <p className="font-bold mb-1">Pruning Efficiency</p>
                  <p>Alpha-Beta pruning significantly reduces the search space compared to standard Minimax!</p>
                </div>
              )}
            </div>
          </div>

          {/* Game Board */}
          <div className="lg:col-span-2">
            <div className="bg-white/10 backdrop-blur-lg rounded-lg p-6 border border-white/20">
              <div className="text-center mb-6">
                {gameOver ? (
                  <div className="space-y-4">
                    <div className="text-3xl font-bold">
                      {winner.winner === 'draw' ? (
                        <span className="text-yellow-400">It's a Draw!</span>
                      ) : winner.winner === playerSymbol ? (
                        <span className="text-green-400">You Win! ðŸŽ‰</span>
                      ) : (
                        <span className="text-red-400">AI Wins! ðŸ¤–</span>
                      )}
                    </div>
                    <button
                      onClick={resetGame}
                      className="px-6 py-3 bg-blue-500 hover:bg-blue-600 rounded-lg transition flex items-center mx-auto"
                    >
                      <RotateCcw className="mr-2" />
                      Play Again
                    </button>
                  </div>
                ) : thinking ? (
                  <div className="text-2xl font-bold text-purple-400 flex items-center justify-center">
                    <Brain className="mr-2 animate-pulse" />
                    AI is thinking...
                  </div>
                ) : isPlayerTurn ? (
                  <div className="text-2xl font-bold text-blue-400">Your Turn ({playerSymbol})</div>
                ) : (
                  <div className="text-2xl font-bold text-red-400">AI's Turn ({aiSymbol})</div>
                )}
              </div>

              <div className="flex items-center justify-center">
                <div className="grid grid-cols-3 gap-2 bg-slate-800/50 p-4 rounded-lg">
                  {board.map((cell, index) => (
                    <div
                      key={index}
                      className={getCellClass(index)}
                      onClick={() => handleCellClick(index)}
                    >
                      {cell}
                    </div>
                  ))}
                </div>
              </div>

              <div className="mt-6 text-center text-sm text-gray-400">
                Move Count: {moveCount}
              </div>
            </div>

            <div className="mt-6 bg-white/10 backdrop-blur-lg rounded-lg p-6 border border-white/20">
              <h2 className="text-xl font-bold mb-4">How It Works</h2>
              
              <div className="space-y-4 text-sm">
                <div className="bg-white/5 p-4 rounded-lg">
                  <h3 className="font-bold text-blue-400 mb-2">Minimax Algorithm</h3>
                  <p className="text-gray-300">
                    A recursive algorithm that explores all possible game states to find the optimal move. 
                    It assumes both players play optimally and evaluates positions from the AI's perspective.
                  </p>
                </div>

                <div className="bg-white/5 p-4 rounded-lg">
                  <h3 className="font-bold text-purple-400 mb-2">Alpha-Beta Pruning</h3>
                  <p className="text-gray-300">
                    An optimization technique that eliminates branches in the game tree that don't need to be explored. 
                    This dramatically reduces computation time (up to 50-90% fewer nodes) while guaranteeing the same result.
                  </p>
                </div>

                <div className="bg-white/5 p-4 rounded-lg">
                  <h3 className="font-bold text-green-400 mb-2">Evaluation Function</h3>
                  <p className="text-gray-300">
                    Scores: +10 for AI win, -10 for player win, 0 for draw. Depth is subtracted/added to prefer 
                    faster wins and slower losses, making the AI play more aggressively.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TicTacToeAI;
